## 七层协议

```
应用层 文件传输 常用协议 HTTP，snmp，FTP

表示层  数据格式化，代码转换，数据加密

会话层  建立，解除会话

传输层  提供端对端的接口 TCP，UDP

网络层  为数据包选择目的主机  IP

数据链路层  传输有地址的帧

物理层   二进制 比特流 的数据形式在物理媒体上传输数据 
```

## UDP和TCP

```
1. UDP（用户数据包协议）：通过端口号和目标端口号把数据包送到目的应用程序
面向无连接的 
   - 数据包易丢失 
   - UDP不知道如何组装这些数据包
2. TCP：保证数据包传输的不可丢失性，通过端口号、目标端口号、序列号把数据完整送达应用程序
面向连接的 
   - 对于数据包易丢失，TCP提供重传
   - TCP头提供用于排序的序列号，用来保证把乱序的数据包组合成一个完整的文件
```

![](E:\Fullstack全栈\Review\9.6_tcp udp区别.png)

### 完整的TCP连接

从下图可以看出，一个完整的 TCP 连接的生命周期包括了“**建立连接**”“**传输数据**”和“**断开连接**”三个阶段。

![image-20200906200433713](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200906200433713.png)



#### 建立连接（三次握手）

```
- 三次握手是客户端和服务端相互发送三个数据包，以确认双方的发送能力和接收能力

  从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。

  然后客户端主动发起连接，发送 同步标志位SYN , 自己变成了SYN-SENT状态。

  服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。

  之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。

- 凡是需要对端确认的，一定消耗TCP报文的序列号。

- 最后客户端还要发送一次的原因是：防止已经失效的连接请求报文突然又传到了服务端，产生错误
```

##### 为啥不是两次 

无法确认客户端的接受能力

##### 不是四次

三次已经达到需求了

##### 三次握手可以携带数据嘛

- 前两次不行，前两次传输如果携带数据的话，服务端要花费大量时间处理这些数据
- 第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

#### 断开连接（四次挥手）

![img](file:///C:\Users\ASUS\Documents\Tencent Files\1358238105\Image\Group2\Q5\8H\Q58HJ7ZSH6G8XW4GF]IGJL6.jpg)

```
双方都处于ESTABLISHED状态。

客户端发送一个FIN标志位，自己进入FIN_WAIT_1状态，这时候客户端进入了半关闭状态，即不能发送数据只能接受从服务端发来的数据。

服务端接受到FIN并返回ACK，自己进入FIN_WAIT状态。

客户端收到ACK，进入FIN_WAIT_2状态。

服务端确认没有要传输的数据之后，在发送一个FIN，同时自己进入LAST_ACK状态。

客户端接受到FIN，进入TIME_WAIT，发送一个ACK给服务端，服务端收到之后回到closed状态。等待2msl后，客户端回到closed状态。
```

##### 标志位

SYN建立连接

FIN表示关闭连接

ack 响应

##### 为什么要四次

TCP连接是全双工信道，单方面断开一头是不行的。两端之间有两条通道，所以断开连接，需要服务端客户端各自断开自己发送和接受数据的通道，所以需要发送两次FIN。

##### 2msl的意义

msl是tcp报文的最大生命周期。2msl就是一个发送和回复所需的最大时间。

为确保服务端能接收到ACK，需要2msl缓冲时间。

因为若服务端没能接收到ack，会重会上一步，重新发送FIN标志位（消耗一个msl），再等客户端发送ack（消耗一个msl）。

所以2msl能保证，要么服务端接受到ack，要么他重新发送FIN。

至此，tcp连接结束。



 在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

[参考](https://www.cnblogs.com/zxpo/p/5234220.html)



## 数据传输的过程

1. ip：把数据包送到目的主机
2. UDP（用户数据包协议）：通过端口号和目标端口号把数据包送到目的应用程序
   - 数据包易丢失
   - UDP不知道如何组装这些数据包
3. TCP：保证数据包传输的不可丢失性，通过端口号、目标端口号、序列号把数据完整送达应用程序
   - 对于数据包易丢失，TCP提供重传
   - TCP头提供用于排序的序列号，用来保证把乱序的数据包组合成一个完整的文件

![image-20200906195705559](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200906195705559.png)

下面我们一起来看下一个数据包从主机 A 旅行到主机 B 的路线：

- 上层将含有“极客时间”的数据包交给传输层；
- 传输层会在数据包前面附加上**TCP 头**，组成新的TCP 数据包，再将新的 TCP数据包交给网络层；
- 网络层再将 IP 头附加到数据包上，组成新的 IP 数据包，并交给底层；
- 数据包被传输到主机 B 的网络层，在这里主机 B 拆开 IP 头信息，并将拆开来的数据部分交给传输层；
- 在传输层，数据包中的 TCP头会被拆开，**并根据 TCP 中所提供的端口号，把数据部分交给上层的应用程序**；
- 最终，含有“极客时间”信息的数据包就旅行到了主机 B 上层应用程序这里。



