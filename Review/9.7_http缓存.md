## HTTP 缓存机制

​	HTTP缓存即是浏览器第一次向服务器发起HTTP请求后，服务器会返回请求的资源，并在响应头中添加一些有关缓存的字段如：cache-control，expires，last-modified，Etag，Date等，之后浏览器再向该服务器请求资源 就可以视情况使用强缓存和协商缓存。 

强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。

协商缓存：浏览器发送请求到服务器，服务器判断是否可以使用本地缓存。

### 四个响应消息头

* Expires 存放一份**绝对的时间**，表示资源失效时间。缺点就是，用户可以改时间。是属于http1.0的
* Cache-Control  max-age字段 存放**相对时间**，就是存放的有效期，这就比较好了。属于http1.1
* Etag 上次请求内容的**hash值**
* Last-Modified 文件**上一次被修改的时间**

## 强缓存和协商缓存

### 强缓存

- 浏览器在请求资源时，会先根据本地缓存中的header中的信息，判断是否命中强缓存，如果命中，则直接从内存中读取，返回304状态码，不会向服务器发送请求。

- 强缓存就是缓存还没有过期，通过Expire、Cache-Control来判断是否过期
- 同时启用**cache-control**优先级高

### 协商缓存

- 协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。
- 先看看是否有**Etag**,如果有就把Etag的值以一个叫做IF-None-Match的请求消息头发给服务器进行决策。

> Etag：根据文件内容通过MD5加密生成一个hash值。

- -  浏览器第一次请求一个a.js，服务器返回a.js的同时，在响应头信息中加上Etag。Etag保证每个资源时唯一的，资源变化会导致Etag变化。
  -  浏览器第二次请求a.js，请求头中会包含if-none-match（也就是之前接受到的Etag），服务器收到if-none-match，与自己的Etag进行比较。
  - 如果相同，返回304
- 没有Etag就看看有没有**Last-Modified**,以IF-Modified-since消息头传给服务器，服务器比较一下，如果文件的上次修改时间相同，就表示文件没有修改，这次的内容和上次的一致，你直接用上次的返回304，否则返回200

- 如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

- **Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。** 

  

## http0.9  http1.X 和http2.X

- http 0.9超文本传输协议
- http 1.X 改进了持久连接，提供虚拟主机的支持
  - 使用文本传输
  - 著名的队头阻塞问题，一次连接完成一次请求
- http 2.X
  - 使用二进制传输，相对更加安全可靠
  - 多路复用，建立一条连接，可以完成多条请求
  - 对协议报使用压缩，降低了网络开销
  - 允许服务器主动推送消息到客户端

## 常见的请求方式

```
GET,POST,HEAD,PUT,DELETE,OPTINS

1. GET 请求数据，把参数包含在URL中，POST 请求数据，通过请求体 request body传递参数。
2. Get只接受ASCII类型的数据，post则没有限制
3. get请求的参数有长度限制，因为浏览器通常都会限制url长度在2k个字节内，而大多数服务器最多只能处理64k大小的url
4. get请求参数会被放到历史记录里面，post请求不会。
5. GET请求会被浏览器主动cache，而POST不会，除非手动设置。

从协议本身来说，没有规定GET传递参数不能放到body， POST传递参数也可以放到querystring
相对来说POST 比GET 更安全一些，但是两种本质上来说都是不安全的，因为http是明文传输的，应该使用https。

重大区别：GET产生一个数据包，POST产生两个数据包。

对于GET方式的请求，浏览器会把http header连同数据包一起发送，服务器响应200(返回数据)；而对于POST，浏览器先发送header，服务器响应100(continue),浏览器再发送data，服务器响应200 ok。
```










